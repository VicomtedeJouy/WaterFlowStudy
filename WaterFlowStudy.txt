import math

import Rhino
import rhinoscriptsyntax as rs
from Rhino import Geometry as g
import Rhino.Geometry.Collections as c
import Rhino.Geometry.Intersect.Intersection as s
    
class RainDrop(object):
    def __init__(self, point3d, ind, facadeMesh, windvect, stepsize, maxsteps, plane):
        self.pos = point3d   # position of the flow
        self.ind = ind
        self.mesh = facadeMesh  # surface mesh of the facade
        self.mpos = self.mesh.ClosestMeshPoint(self.pos, self.ind)   # mesh position of the flow
        self.wind = windvect
        self.antol = self.mesh.mat[self.ind][0]   # tolerance angle
        self.androp = self.mesh.mat[self.ind][1] # drop angle
        self.stepsize = stepsize    # interval of steps on the mesh
        self.points = [self.pos]  # flow points history
        self.curveTemp = [self.pos]  # stock a journey on a srf, then back to 0 when changes
        self.waterPath = [] # gets the different curves of a water path
        self.state = 'on'   # if the flow is on or off the facade or finished
        self.maxsteps = maxsteps    # max numbers of iterations
        self.check = False  # True if the flow has to be checked, false otherwise
        self.plane = plane  # plane that define the ground

    def nextStep(self):
        newPlane = rs.PlaneFromNormal(self.pos, self.mesh.NormalAt(self.mpos))
        # create a vector from newFrame XAxis
        downVect = newPlane.XAxis
        # figure out how much to rotate it.
        deltaAngle = g.Vector3d.VectorAngle( downVect, g.Vector3d(0.0, 0.0, -1.0), newPlane )
        # rotate it in the plane
        downVect.Rotate( deltaAngle, newPlane.ZAxis)
        # set the length
        downVect = rs.VectorScale(downVect, self.stepsize)
        spacePoint = g.Point3d.Add(self.pos, downVect)
        # find next point
        newPoint = self.mesh.ClosestPoint(spacePoint)

        if newPoint.Z >= self.pos.Z: # if higher
            self.state = 'finished'
        #elif self.checkTolerance(newPoint) == True: # if too close
        #    self.state = 'finished'
        else:
            self.updatePos( newPoint )

    def nextSurf(self):
        # find the next intersection with the mesh
        self.pos = g.Point3d.Add(self.pos, g.Vector3d(0., 0., -1.) * self.stepsize/10)
        ray = g.Ray3d(self.pos, g.Vector3d(0., 0., -1.))
        num = s.MeshRay(self.mesh, ray)
        if num > 0: # if it exists
            self.nextCrv()
            newPoint = ray.PointAt(num)
            self.updatePos(newPoint)
            self.state = 'on'   # the waterflow is on the facade again
        else :  # if not
            self.nextCrv()
            #self.pos.Transform(g.Transform.PlanarProjection(self.plane))
            #self.points.append(self.pos)
            self.state = 'finished' # the waterflow has ended its path

    def nextCrv(self):
        # separates the curves after a 'srf to srf' journey
        self.waterPath.append(g.PolylineCurve(self.curveTemp))
        self.curveTemp = []
        print len(self.waterPath)

    def updatePos(self, newPoint):
        #   change flow position to the new point
        self.points.append(newPoint)
        self.curveTemp.append(newPoint)
        self.pos = newPoint
        self.mpos = self.mesh.ClosestMeshPoint(self.pos, self.stepsize)
        
    def tol(self):
        #   tolerance angle check function
        vect1 = rs.VectorCreate(self.points[-2], self.points[-3])
        vect2 = rs.VectorCreate(self.points[-1], self.points[-2])
        norm = self.mesh.NormalAt(self.mpos)
        alpha = g.Vector3d.VectorAngle(vect1, vect2)
        if alpha > self.antol and rs.VectorDotProduct(norm, g.Vector3d(0., 0., 1.)) < 0 :  # if the angle between 2 moves larger than tolerance
            self.state = 'off'  # the waterflow is off the facade
        
    def drop(self):
        #   drop angle check function
        move = rs.VectorCreate(self.points[-1], self.points[-2])
        alpha = g.Vector3d.VectorAngle(move, g.Vector3d(0., 0., -1.))
        norm = self.mesh.NormalAt(self.mpos)
        if alpha > (math.pi/2-self.androp) and rs.VectorDotProduct(norm, g.Vector3d(0., 0., 1.)) < 0 : # if the geometry is too steep
            self.state = 'off'  # the waterflow is off the facade
            
    def toldrop(self):
        vect1 = rs.VectorCreate(self.points[-2], self.points[-3])
        vect2 = rs.VectorCreate(self.points[-1], self.points[-2])
        norm = self.mesh.NormalAt(self.mpos)
        alpha = g.Vector3d.VectorAngle(vect1, vect2)
        if alpha > self.antol and rs.VectorDotProduct(norm, g.Vector3d(0., 0., 1.)) < 0 :  # if the angle between 2 moves larger than tolerance
            self.state = 'off'  # the waterflow is off the facade
        alpha = g.Vector3d.VectorAngle(vect2, g.Vector3d(0., 0., -1.))
        if alpha > (math.pi/2-self.androp) and rs.VectorDotProduct(norm, g.Vector3d(0., 0., 1.)) < 0 : # if the geometry is too steep
            self.state = 'off'  # the waterflow is off the facade


class FacadeMesh(object):   #   list of mesh, to be used like a single mesh
    def __init__(self, mesh, mat):
        self.length = len(matMesh)
        self.obj = [mesh[i] for i in range(self.length)]
        self.mat = [mat[i] for i in range(self.length)]
        
    #   return the index of the mesh in the list
    def ind(self, mesh):
        return self.obj.index(mesh)
        
    #   rewriting this methods to use them on facadeMesh as if it was a simple mesh
    def ClosestPoint(self, point):
        index = 0
        pt = self.obj[0].ClosestPoint(point)
        d = point.DistanceTo(pt)
        for i in range(self.length):
            ptTemp = self.obj[i].ClosestPoint(point)
            dd = point.DistanceTo(ptTemp)
            if dd < d:
                index = i
                d = dd
                pt = ptTemp
         return(pt, i)  #   return both the point and the index of the mesh it is on
         
     def ClosestMeshPoint(self, point, ind):
         return self.obj[ind].ClosestMeshPoint(point, 0.)
         
     def NormalAt(self, mPoint, ind):
         return self.obj[ind].NormalAt(mPoint)
         
     def MeshRay(self, ray):
         startPt = ray.Position
         l = []
         for i in range(self.length):
            num = self.obj[0].MeshRay(ray)
            if num > 0:
                temp = []
                pt = ray.PointAt(num)
                temp.append([ray.PointAt(num), startPt.DistanceTo(pt), i])
                l.apend(temp)
        if not l:   #   if the list is empty, return nothing
            return([])
        else:   #   return the closeset point and the index of the mesh it is on
            temp = [l[i][1] for i in range(len(l))]
            index = temp.index(min(temp))
            return [l[index][0], l[index][2]]



def main(startPoint, facadeMesh, windVect, stepSize, maxSteps, endPlane):
    init = start(facadeMesh, point, windVect)
    if not init:
        return
    startPoint = init[0]
    ind = init[1]
    drop = RainDrop(startPoint, ind, facadeMesh, windvect, stepsize, maxsteps, plane)
    i = 0
    while drop.state != 'finished' and i < drop.maxsteps:
        i += 1
        if i > 4:
            drop.check = True
        if drop.check == True:
            # check both (not to define twice same objects)
            drop.toldrop()
        if drop.state == 'on':  # if the waterflow is on the facade
            drop.nextStep()
        else: # if the waterflow is off the facade (did not used if self.check == 'off' to gain a test)
            drop.check = False  # stop checking until it reaches the facade again
            drop.nextSurf()
            i = 0   # re initialisation of the count to be sure that it is not overtaken
    # creation of the curves
    curves = []
    for cu in drop.waterPath:
        #cu = g.PolylineCurve(cu)
        #cu.Simplify(0, 0.1 * self.stepsize, 3.14)
        curves.append(cu)
        print rs.CurveLength(cu)
    return curves


def start(facadeMesh, point, windVect):
    ray = g.Ray3d(point, windVect)
    return facadeMesh.mesh.MeshRay(ray)


facadeMesh = FacadeMesh(mesh, mat)
for pt in startPoint:
    a.append(main(pt, facadeMesh, windVect, stepSize, maxSteps, endPlane))
